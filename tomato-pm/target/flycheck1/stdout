{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `std`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `x86_64-unknown-none` target may not support the standard library","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`std` is required by `tomato_pm` because it does not declare `#![no_std]`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `std`\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the `x86_64-unknown-none` target may not support the standard library\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `std` is required by `tomato_pm` because it does not declare `#![no_std]`\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot resolve a prelude import","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot resolve a prelude import\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `std`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":4,"byte_end":7,"line_start":1,"line_end":1,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":5,"highlight_end":8}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `x86_64-unknown-none` target may not support the standard library","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `std`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:1:5\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use std::collections::HashMap;\n  \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the `x86_64-unknown-none` target may not support the standard library\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `std`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `x86_64-unknown-none` target may not support the standard library","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`std` is required by `tomato_pm` because it does not declare `#![no_std]`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `std`\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the `x86_64-unknown-none` target may not support the standard library\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `std` is required by `tomato_pm` because it does not declare `#![no_std]`\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot resolve a prelude import","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot resolve a prelude import\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `std`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":4,"byte_end":7,"line_start":1,"line_end":1,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":5,"highlight_end":8}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `x86_64-unknown-none` target may not support the standard library","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `std`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:1:5\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use std::collections::HashMap;\n  \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the `x86_64-unknown-none` target may not support the standard library\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `vec` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":261,"byte_end":264,"line_start":6,"line_end":6,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"    let mut to_resolve = vec![package.to_string()];","highlight_start":26,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `vec` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:6:26\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut to_resolve = vec![package.to_string()];\n  \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `vec` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":261,"byte_end":264,"line_start":6,"line_end":6,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"    let mut to_resolve = vec![package.to_string()];","highlight_start":26,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `vec` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:6:26\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut to_resolve = vec![package.to_string()];\n  \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":831,"byte_end":837,"line_start":25,"line_end":25,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"                format!(\"{}.{}\", current_section, key_part)","highlight_start":17,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:25:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 format!(\"{}.{}\", current_section, key_part)\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":831,"byte_end":837,"line_start":25,"line_end":25,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"                format!(\"{}.{}\", current_section, key_part)","highlight_start":17,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:25:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 format!(\"{}.{}\", current_section, key_part)\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1353,"byte_end":1359,"line_start":38,"line_end":38,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"            return Err(format!(\"Invalid line {}: {}\", line_num + 1, line));","highlight_start":24,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:38:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             return Err(format!(\"Invalid line {}: {}\", line_num + 1, line));\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1353,"byte_end":1359,"line_start":38,"line_end":38,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"            return Err(format!(\"Invalid line {}: {}\", line_num + 1, line));","highlight_start":24,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:38:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             return Err(format!(\"Invalid line {}: {}\", line_num + 1, line));\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":2156,"byte_end":2162,"line_start":61,"line_end":61,"column_start":30,"column_end":36,"is_primary":true,"text":[{"text":"            output.push_str(&format!(\"[{}]\\n\", section));","highlight_start":30,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:61:30\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             output.push_str(&format!(\"[{}]\\n\", section));\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":2156,"byte_end":2162,"line_start":61,"line_end":61,"column_start":30,"column_end":36,"is_primary":true,"text":[{"text":"            output.push_str(&format!(\"[{}]\\n\", section));","highlight_start":30,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:61:30\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             output.push_str(&format!(\"[{}]\\n\", section));\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":2262,"byte_end":2268,"line_start":64,"line_end":64,"column_start":30,"column_end":36,"is_primary":true,"text":[{"text":"            output.push_str(&format!(\"{} = \\\"{}\\\"\\n\", key, value));","highlight_start":30,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:64:30\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             output.push_str(&format!(\"{} = \\\"{}\\\"\\n\", key, value));\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":2262,"byte_end":2268,"line_start":64,"line_end":64,"column_start":30,"column_end":36,"is_primary":true,"text":[{"text":"            output.push_str(&format!(\"{} = \\\"{}\\\"\\n\", key, value));","highlight_start":30,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:64:30\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             output.push_str(&format!(\"{} = \\\"{}\\\"\\n\", key, value));\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `vec` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1262,"byte_end":1265,"line_start":30,"line_end":30,"column_start":59,"column_end":62,"is_primary":true,"text":[{"text":"            available.entry(\"base\".to_string()).or_insert(vec![]);","highlight_start":59,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:30:59\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             available.entry(\"base\".to_string()).or_insert(vec![]);\n   \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `vec` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1262,"byte_end":1265,"line_start":30,"line_end":30,"column_start":59,"column_end":62,"is_primary":true,"text":[{"text":"            available.entry(\"base\".to_string()).or_insert(vec![]);","highlight_start":59,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:30:59\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             available.entry(\"base\".to_string()).or_insert(vec![]);\n   \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `vec` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1332,"byte_end":1335,"line_start":31,"line_end":31,"column_start":61,"column_end":64,"is_primary":true,"text":[{"text":"            available.entry(\"kernel\".to_string()).or_insert(vec![\"base\".to_string()]);","highlight_start":61,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:31:61\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m31\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             available.entry(\"kernel\".to_string()).or_insert(vec![\"base\".to_string()]);\n   \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `vec` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1332,"byte_end":1335,"line_start":31,"line_end":31,"column_start":61,"column_end":64,"is_primary":true,"text":[{"text":"            available.entry(\"kernel\".to_string()).or_insert(vec![\"base\".to_string()]);","highlight_start":61,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:31:61\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m31\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             available.entry(\"kernel\".to_string()).or_insert(vec![\"base\".to_string()]);\n   \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2089,"byte_end":2096,"line_start":47,"line_end":47,"column_start":35,"column_end":42,"is_primary":true,"text":[{"text":"                        Err(e) => println!(\"Error loading: {}\", e),","highlight_start":35,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:47:35\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2089,"byte_end":2096,"line_start":47,"line_end":47,"column_start":35,"column_end":42,"is_primary":true,"text":[{"text":"                        Err(e) => println!(\"Error loading: {}\", e),","highlight_start":35,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:47:35\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2192,"byte_end":2199,"line_start":50,"line_end":50,"column_start":27,"column_end":34,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Dependency error: {}\", e),","highlight_start":27,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:50:27\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Dependency error: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2192,"byte_end":2199,"line_start":50,"line_end":50,"column_start":27,"column_end":34,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Dependency error: {}\", e),","highlight_start":27,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:50:27\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Dependency error: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2927,"byte_end":2934,"line_start":67,"line_end":67,"column_start":27,"column_end":34,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Error loading: {}\", e),","highlight_start":27,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:67:27\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m67\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2927,"byte_end":2934,"line_start":67,"line_end":67,"column_start":27,"column_end":34,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Error loading: {}\", e),","highlight_start":27,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:67:27\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m67\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3427,"byte_end":3434,"line_start":81,"line_end":81,"column_start":27,"column_end":34,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Error loading: {}\", e),","highlight_start":27,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:81:27\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m81\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3427,"byte_end":3434,"line_start":81,"line_end":81,"column_start":27,"column_end":34,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Error loading: {}\", e),","highlight_start":27,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:81:27\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m81\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":4066,"byte_end":4073,"line_start":97,"line_end":97,"column_start":19,"column_end":26,"is_primary":true,"text":[{"text":"        Err(e) => println!(\"Command error: {}\", e),","highlight_start":19,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:97:19\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m97\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(e) => println!(\"Command error: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":4066,"byte_end":4073,"line_start":97,"line_end":97,"column_start":19,"column_end":26,"is_primary":true,"text":[{"text":"        Err(e) => println!(\"Command error: {}\", e),","highlight_start":19,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:97:19\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m97\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(e) => println!(\"Command error: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":945,"byte_end":951,"line_start":29,"line_end":29,"column_start":18,"column_end":24,"is_primary":true,"text":[{"text":"        _ => Err(format!(\"Unknown command: {}\", args[1])),","highlight_start":18,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:29:18\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m29\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(format!(\"Unknown command: {}\", args[1])),\n   \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":945,"byte_end":951,"line_start":29,"line_end":29,"column_start":18,"column_end":24,"is_primary":true,"text":[{"text":"        _ => Err(format!(\"Unknown command: {}\", args[1])),","highlight_start":18,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:29:18\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m29\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(format!(\"Unknown command: {}\", args[1])),\n   \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":1002,"byte_end":1008,"line_start":33,"line_end":33,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:33:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m33\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1697,"byte_end":1704,"line_start":39,"line_end":39,"column_start":37,"column_end":44,"is_primary":true,"text":[{"text":"                                    println!(\"Installing {}\", dep);","highlight_start":37,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:39:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"Installing {}\", dep);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":1002,"byte_end":1008,"line_start":33,"line_end":33,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:33:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m33\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1963,"byte_end":1970,"line_start":44,"line_end":44,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"                                println!(\"Error saving: {}\", e);","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:44:33\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m44\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"Error saving: {}\", e);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1697,"byte_end":1704,"line_start":39,"line_end":39,"column_start":37,"column_end":44,"is_primary":true,"text":[{"text":"                                    println!(\"Installing {}\", dep);","highlight_start":37,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:39:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"Installing {}\", dep);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2608,"byte_end":2615,"line_start":59,"line_end":59,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                            println!(\"Error saving: {}\", e);","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:59:29\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m59\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"Error saving: {}\", e);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1963,"byte_end":1970,"line_start":44,"line_end":44,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"                                println!(\"Error saving: {}\", e);","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:44:33\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m44\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"Error saving: {}\", e);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2704,"byte_end":2711,"line_start":61,"line_end":61,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                            println!(\"Removed {}\", pkg);","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:61:29\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"Removed {}\", pkg);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2608,"byte_end":2615,"line_start":59,"line_end":59,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                            println!(\"Error saving: {}\", e);","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:59:29\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m59\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"Error saving: {}\", e);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2815,"byte_end":2822,"line_start":64,"line_end":64,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                        println!(\"Package {} not installed\", pkg);","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:64:25\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         println!(\"Package {} not installed\", pkg);\n   \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2704,"byte_end":2711,"line_start":61,"line_end":61,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                            println!(\"Removed {}\", pkg);","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:61:29\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"Removed {}\", pkg);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2815,"byte_end":2822,"line_start":64,"line_end":64,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                        println!(\"Package {} not installed\", pkg);","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:64:25\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         println!(\"Package {} not installed\", pkg);\n   \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3168,"byte_end":3175,"line_start":74,"line_end":74,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                        println!(\"No packages installed\");","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:74:25\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m74\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         println!(\"No packages installed\");\n   \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3168,"byte_end":3175,"line_start":74,"line_end":74,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                        println!(\"No packages installed\");","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:74:25\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m74\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         println!(\"No packages installed\");\n   \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3310,"byte_end":3317,"line_start":77,"line_end":77,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                            println!(\"{}\", pkg);","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:77:29\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m77\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"{}\", pkg);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3310,"byte_end":3317,"line_start":77,"line_end":77,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                            println!(\"{}\", pkg);","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:77:29\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m77\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"{}\", pkg);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3931,"byte_end":3938,"line_start":91,"line_end":91,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                            println!(\"{}\", key);","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:91:29\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m91\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"{}\", key);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `println` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3931,"byte_end":3938,"line_start":91,"line_end":91,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                            println!(\"{}\", key);","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `println` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:91:29\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m91\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   println!(\"{}\", key);\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":108,"byte_end":114,"line_start":3,"line_end":3,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":64,"highlight_end":70}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":72,"byte_end":72,"line_start":3,"line_end":3,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:64\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn resolve_dependencies\u001b[92m<String>\u001b[0m(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":116,"byte_end":119,"line_start":3,"line_end":3,"column_start":72,"column_end":75,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":72,"highlight_end":75}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:72\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":120,"byte_end":126,"line_start":3,"line_end":3,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":76,"highlight_end":82}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":72,"byte_end":72,"line_start":3,"line_end":3,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:76\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn resolve_dependencies\u001b[92m<String>\u001b[0m(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":133,"byte_end":139,"line_start":3,"line_end":3,"column_start":89,"column_end":95,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":89,"highlight_end":95}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:89\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":140,"byte_end":143,"line_start":3,"line_end":3,"column_start":96,"column_end":99,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":96,"highlight_end":99}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:96\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":144,"byte_end":150,"line_start":3,"line_end":3,"column_start":100,"column_end":106,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":100,"highlight_end":106}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":72,"byte_end":72,"line_start":3,"line_end":3,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:100\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn resolve_dependencies\u001b[92m<String>\u001b[0m(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":153,"byte_end":159,"line_start":3,"line_end":3,"column_start":109,"column_end":115,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":109,"highlight_end":115}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":72,"byte_end":72,"line_start":3,"line_end":3,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:109\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                                                             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn resolve_dependencies\u001b[92m<String>\u001b[0m(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":305,"byte_end":309,"line_start":8,"line_end":8,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"    while let Some(pkg) = to_resolve.pop() {","highlight_start":15,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:8:15\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     while let Some(pkg) = to_resolve.pop() {\n  \u001b[1m\u001b[96m|\u001b[0m               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":457,"byte_end":461,"line_start":14,"line_end":14,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(deps) = available.get(&pkg) {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:14:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m14\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(deps) = available.get(&pkg) {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":773,"byte_end":775,"line_start":27,"line_end":27,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(resolved)","highlight_start":5,"highlight_end":7}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:27:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m27\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(resolved)\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":86,"byte_end":92,"line_start":6,"line_end":6,"column_start":11,"column_end":17,"is_primary":true,"text":[{"text":"    path: String,","highlight_start":11,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:6:11\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     path: String,\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":281,"byte_end":284,"line_start":16,"line_end":16,"column_start":48,"column_end":51,"is_primary":true,"text":[{"text":"    pub fn load_installed(&self) -> io::Result<Vec<String>> {","highlight_start":48,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:16:48\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn load_installed(&self) -> io::Result<Vec<String>> {\n   \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":285,"byte_end":291,"line_start":16,"line_end":16,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"    pub fn load_installed(&self) -> io::Result<Vec<String>> {","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":104,"byte_end":104,"line_start":9,"line_end":9,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"impl PackageDB {","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:16:52\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn load_installed(&self) -> io::Result<Vec<String>> {\n   \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m| \u001b[0mimpl\u001b[92m<String>\u001b[0m PackageDB {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":414,"byte_end":416,"line_start":19,"line_end":19,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(content.lines().map(|s| s.to_string()).collect())","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fs;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:19:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(content.lines().map(|s| s.to_string()).collect())\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":498,"byte_end":500,"line_start":21,"line_end":21,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Vec::new())","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fs;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:21:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Vec::new())\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":579,"byte_end":585,"line_start":25,"line_end":25,"column_start":46,"column_end":52,"is_primary":true,"text":[{"text":"    pub fn save_installed(&self, packages: &[String]) -> io::Result<()> {","highlight_start":46,"highlight_end":52}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:25:46\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn save_installed(&self, packages: &[String]) -> io::Result<()> {\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":828,"byte_end":830,"line_start":32,"line_end":32,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(installed.contains(&package.to_string()))","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fs;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:32:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m32\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(installed.contains(&package.to_string()))\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":29,"byte_end":35,"line_start":1,"line_end":1,"column_start":30,"column_end":36,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":30,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:1:30\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_command(args: &[String]) -> Result<Command, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":41,"byte_end":47,"line_start":1,"line_end":1,"column_start":42,"column_end":48,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":42,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:1:42\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_command(args: &[String]) -> Result<Command, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":57,"byte_end":63,"line_start":1,"line_end":1,"column_start":58,"column_end":64,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":58,"highlight_end":64}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":20,"byte_end":20,"line_start":1,"line_end":1,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:1:58\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_command(args: &[String]) -> Result<Command, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn parse_command\u001b[92m<String>\u001b[0m(args: &[String]) -> Result<Command, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                     \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":108,"byte_end":111,"line_start":3,"line_end":3,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"        return Err(\"Usage: tomato-pm <command> [package]\".to_string());","highlight_start":16,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:3:16\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         return Err(\"Usage: tomato-pm <command> [package]\".to_string());\n  \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":278,"byte_end":281,"line_start":9,"line_end":9,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(\"install requires a package name\".to_string())","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:9:17\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"install requires a package name\".to_string())\n  \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":368,"byte_end":370,"line_start":11,"line_end":11,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Command::Install(args[2].clone()))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:11:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m11\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Command::Install(args[2].clone()))\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":519,"byte_end":522,"line_start":16,"line_end":16,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(\"remove requires a package name\".to_string())","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:16:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"remove requires a package name\".to_string())\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":608,"byte_end":610,"line_start":18,"line_end":18,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Command::Remove(args[2].clone()))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:18:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m18\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Command::Remove(args[2].clone()))\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":690,"byte_end":692,"line_start":21,"line_end":21,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"        \"list\" => Ok(Command::List),","highlight_start":19,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:21:19\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         \"list\" => Ok(Command::List),\n   \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":782,"byte_end":785,"line_start":24,"line_end":24,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(\"search requires a query\".to_string())","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:24:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m24\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"search requires a query\".to_string())\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":864,"byte_end":866,"line_start":26,"line_end":26,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Command::Search(args[2].clone()))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:26:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Command::Search(args[2].clone()))\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":941,"byte_end":944,"line_start":29,"line_end":29,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(format!(\"Unknown command: {}\", args[1])),","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:29:14\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m29\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(format!(\"Unknown command: {}\", args[1])),\n   \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":1050,"byte_end":1056,"line_start":35,"line_end":35,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"    Install(String),","highlight_start":13,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:35:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Install(String),\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":1071,"byte_end":1077,"line_start":36,"line_end":36,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    Remove(String),","highlight_start":12,"highlight_end":18}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:36:12\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m36\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Remove(String),\n   \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":1103,"byte_end":1109,"line_start":38,"line_end":38,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    Search(String),","highlight_start":12,"highlight_end":18}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:38:12\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Search(String),\n   \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":70,"byte_end":76,"line_start":3,"line_end":3,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":37,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:3:37\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":85,"byte_end":91,"line_start":3,"line_end":3,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":51,"byte_end":51,"line_start":3,"line_end":3,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:3:52\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn parse_toml\u001b[92m<String>\u001b[0m(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                  \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":93,"byte_end":99,"line_start":3,"line_end":3,"column_start":60,"column_end":66,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":60,"highlight_end":66}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":51,"byte_end":51,"line_start":3,"line_end":3,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:3:60\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn parse_toml\u001b[92m<String>\u001b[0m(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                  \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":102,"byte_end":108,"line_start":3,"line_end":3,"column_start":69,"column_end":75,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":69,"highlight_end":75}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":51,"byte_end":51,"line_start":3,"line_end":3,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:3:69\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn parse_toml\u001b[92m<String>\u001b[0m(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                  \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":557,"byte_end":561,"line_start":18,"line_end":18,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(eq_pos) = line.find('=') {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:18:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m18\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(eq_pos) = line.find('=') {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1349,"byte_end":1352,"line_start":38,"line_end":38,"column_start":20,"column_end":23,"is_primary":true,"text":[{"text":"            return Err(format!(\"Invalid line {}: {}\", line_num + 1, line));","highlight_start":20,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:38:20\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             return Err(format!(\"Invalid line {}: {}\", line_num + 1, line));\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1431,"byte_end":1433,"line_start":42,"line_end":42,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(map)","highlight_start":5,"highlight_end":7}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:42:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m42\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(map)\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1481,"byte_end":1487,"line_start":45,"line_end":45,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":37,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:45:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn serialize_toml(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1489,"byte_end":1495,"line_start":45,"line_end":45,"column_start":45,"column_end":51,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":45,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:45:45\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn serialize_toml(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1501,"byte_end":1507,"line_start":45,"line_end":45,"column_start":57,"column_end":63,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":57,"highlight_end":63}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:45:57\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn serialize_toml(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                                                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1578,"byte_end":1584,"line_start":47,"line_end":47,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"    let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();","highlight_start":31,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:47:31\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1586,"byte_end":1589,"line_start":47,"line_end":47,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"    let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();","highlight_start":39,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:47:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1591,"byte_end":1597,"line_start":47,"line_end":47,"column_start":44,"column_end":50,"is_primary":true,"text":[{"text":"    let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();","highlight_start":44,"highlight_end":50}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:47:44\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1599,"byte_end":1605,"line_start":47,"line_end":47,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"    let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:47:52\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1676,"byte_end":1680,"line_start":50,"line_end":50,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(dot_pos) = key.find('.') {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:50:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(dot_pos) = key.find('.') {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":294,"byte_end":300,"line_start":12,"line_end":12,"column_start":20,"column_end":26,"is_primary":true,"text":[{"text":"pub fn run(args: &[String]) {","highlight_start":20,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:12:20\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn run(args: &[String]) {\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":409,"byte_end":411,"line_start":15,"line_end":15,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(Command::Install(pkg)) => {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:15:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m15\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(Command::Install(pkg)) => {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":585,"byte_end":587,"line_start":18,"line_end":18,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"            if let Ok(content) = std::fs::read_to_string(\"/var/lib/tomato/available.toml\") {","highlight_start":20,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:18:20\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m18\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Ok(content) = std::fs::read_to_string(\"/var/lib/tomato/available.toml\") {\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":683,"byte_end":685,"line_start":19,"line_end":19,"column_start":24,"column_end":26,"is_primary":true,"text":[{"text":"                if let Ok(parsed) = parse_toml(&content) {","highlight_start":24,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:19:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Ok(parsed) = parse_toml(&content) {\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":937,"byte_end":940,"line_start":23,"line_end":23,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"                            let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();","highlight_start":39,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();\n   \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":941,"byte_end":947,"line_start":23,"line_end":23,"column_start":43,"column_end":49,"is_primary":true,"text":[{"text":"                            let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();","highlight_start":43,"highlight_end":49}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":285,"byte_end":285,"line_start":12,"line_end":12,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"pub fn run(args: &[String]) {","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn run\u001b[92m<String>\u001b[0m(args: &[String]) {\n   \u001b[1m\u001b[96m|\u001b[0m           \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1438,"byte_end":1440,"line_start":34,"line_end":34,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(deps) => {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:34:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m34\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(deps) => {\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1526,"byte_end":1528,"line_start":36,"line_end":36,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"                        Ok(mut installed) => {","highlight_start":25,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:36:25\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m36\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         Ok(mut installed) => {\n   \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1889,"byte_end":1892,"line_start":43,"line_end":43,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"                            if let Err(e) = db.save_installed(&installed) {","highlight_start":36,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:43:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m43\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   if let Err(e) = db.save_installed(&installed) {\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2079,"byte_end":2082,"line_start":47,"line_end":47,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        Err(e) => println!(\"Error loading: {}\", e),","highlight_start":25,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:47:25\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2182,"byte_end":2185,"line_start":50,"line_end":50,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Dependency error: {}\", e),","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:50:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Dependency error: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2264,"byte_end":2266,"line_start":53,"line_end":53,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(Command::Remove(pkg)) => {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:53:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m53\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(Command::Remove(pkg)) => {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2352,"byte_end":2354,"line_start":55,"line_end":55,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(mut installed) => {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:55:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(mut installed) => {\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2403,"byte_end":2407,"line_start":56,"line_end":56,"column_start":28,"column_end":32,"is_primary":true,"text":[{"text":"                    if let Some(pos) = installed.iter().position(|p| p == &pkg) {","highlight_start":28,"highlight_end":32}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:56:28\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m56\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     if let Some(pos) = installed.iter().position(|p| p == &pkg) {\n   \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2538,"byte_end":2541,"line_start":58,"line_end":58,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"                        if let Err(e) = db.save_installed(&installed) {","highlight_start":32,"highlight_end":35}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:58:32\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m58\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if let Err(e) = db.save_installed(&installed) {\n   \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2917,"byte_end":2920,"line_start":67,"line_end":67,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Error loading: {}\", e),","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:67:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m67\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2996,"byte_end":2998,"line_start":70,"line_end":70,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(Command::List) => {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:70:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m70\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(Command::List) => {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3077,"byte_end":3079,"line_start":72,"line_end":72,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(installed) => {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:72:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m72\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(installed) => {\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3417,"byte_end":3420,"line_start":81,"line_end":81,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Error loading: {}\", e),","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:81:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m81\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3496,"byte_end":3498,"line_start":84,"line_end":84,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(Command::Search(query)) => {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:84:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m84\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(Command::Search(query)) => {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3611,"byte_end":3617,"line_start":86,"line_end":86,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            let mut available: HashMap<String, Vec<String>> = HashMap::new();","highlight_start":40,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":285,"byte_end":285,"line_start":12,"line_end":12,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"pub fn run(args: &[String]) {","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:86:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let mut available: HashMap<String, Vec<String>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn run\u001b[92m<String>\u001b[0m(args: &[String]) {\n   \u001b[1m\u001b[96m|\u001b[0m           \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3619,"byte_end":3622,"line_start":86,"line_end":86,"column_start":48,"column_end":51,"is_primary":true,"text":[{"text":"            let mut available: HashMap<String, Vec<String>> = HashMap::new();","highlight_start":48,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:86:48\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let mut available: HashMap<String, Vec<String>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3623,"byte_end":3629,"line_start":86,"line_end":86,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"            let mut available: HashMap<String, Vec<String>> = HashMap::new();","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":285,"byte_end":285,"line_start":12,"line_end":12,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"pub fn run(args: &[String]) {","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:86:52\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let mut available: HashMap<String, Vec<String>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn run\u001b[92m<String>\u001b[0m(args: &[String]) {\n   \u001b[1m\u001b[96m|\u001b[0m           \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3670,"byte_end":3672,"line_start":87,"line_end":87,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"            if let Ok(content) = std::fs::read_to_string(\"/var/lib/tomato/available.toml\") {","highlight_start":20,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:87:20\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m87\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Ok(content) = std::fs::read_to_string(\"/var/lib/tomato/available.toml\") {\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3768,"byte_end":3770,"line_start":88,"line_end":88,"column_start":24,"column_end":26,"is_primary":true,"text":[{"text":"                if let Ok(parsed) = parse_toml(&content) {","highlight_start":24,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:88:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Ok(parsed) = parse_toml(&content) {\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":4056,"byte_end":4059,"line_start":97,"line_end":97,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"        Err(e) => println!(\"Command error: {}\", e),","highlight_start":9,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:97:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m97\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(e) => println!(\"Command error: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Vec`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":187,"byte_end":190,"line_start":4,"line_end":4,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"    let mut resolved = Vec::new();","highlight_start":24,"highlight_end":27}],"label":"use of undeclared type `Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `Vec`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:4:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut resolved = Vec::new();\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":108,"byte_end":114,"line_start":3,"line_end":3,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":64,"highlight_end":70}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":72,"byte_end":72,"line_start":3,"line_end":3,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:64\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn resolve_dependencies\u001b[92m<String>\u001b[0m(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":200,"byte_end":209,"line_start":12,"line_end":12,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"            path: path.to_string(),","highlight_start":24,"highlight_end":33}],"label":"method not found in `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:12:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             path: path.to_string(),\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":116,"byte_end":119,"line_start":3,"line_end":3,"column_start":72,"column_end":75,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":72,"highlight_end":75}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:72\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":120,"byte_end":126,"line_start":3,"line_end":3,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":76,"highlight_end":82}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":72,"byte_end":72,"line_start":3,"line_end":3,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:76\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn resolve_dependencies\u001b[92m<String>\u001b[0m(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":133,"byte_end":139,"line_start":3,"line_end":3,"column_start":89,"column_end":95,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":89,"highlight_end":95}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:89\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":140,"byte_end":143,"line_start":3,"line_end":3,"column_start":96,"column_end":99,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":96,"highlight_end":99}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:96\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":144,"byte_end":150,"line_start":3,"line_end":3,"column_start":100,"column_end":106,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":100,"highlight_end":106}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":72,"byte_end":72,"line_start":3,"line_end":3,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:100\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn resolve_dependencies\u001b[92m<String>\u001b[0m(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":153,"byte_end":159,"line_start":3,"line_end":3,"column_start":109,"column_end":115,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":109,"highlight_end":115}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":72,"byte_end":72,"line_start":3,"line_end":3,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:3:109\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn resolve_dependencies(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                                                             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn resolve_dependencies\u001b[92m<String>\u001b[0m(package: &str, available: &HashMap<String, Vec<String>>) -> Result<Vec<String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":305,"byte_end":309,"line_start":8,"line_end":8,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"    while let Some(pkg) = to_resolve.pop() {","highlight_start":15,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:8:15\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     while let Some(pkg) = to_resolve.pop() {\n  \u001b[1m\u001b[96m|\u001b[0m               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":457,"byte_end":461,"line_start":14,"line_end":14,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(deps) = available.get(&pkg) {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:14:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m14\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(deps) = available.get(&pkg) {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":773,"byte_end":775,"line_start":27,"line_end":27,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(resolved)","highlight_start":5,"highlight_end":7}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\core\\solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::{HashMap, HashSet};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:27:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m27\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(resolved)\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":86,"byte_end":92,"line_start":6,"line_end":6,"column_start":11,"column_end":17,"is_primary":true,"text":[{"text":"    path: String,","highlight_start":11,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:6:11\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     path: String,\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":281,"byte_end":284,"line_start":16,"line_end":16,"column_start":48,"column_end":51,"is_primary":true,"text":[{"text":"    pub fn load_installed(&self) -> io::Result<Vec<String>> {","highlight_start":48,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:16:48\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn load_installed(&self) -> io::Result<Vec<String>> {\n   \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":285,"byte_end":291,"line_start":16,"line_end":16,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"    pub fn load_installed(&self) -> io::Result<Vec<String>> {","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":104,"byte_end":104,"line_start":9,"line_end":9,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"impl PackageDB {","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:16:52\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn load_installed(&self) -> io::Result<Vec<String>> {\n   \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m| \u001b[0mimpl\u001b[92m<String>\u001b[0m PackageDB {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":441,"byte_end":442,"line_start":19,"line_end":19,"column_start":40,"column_end":41,"is_primary":false,"text":[{"text":"            Ok(content.lines().map(|s| s.to_string()).collect())","highlight_start":40,"highlight_end":41}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\storage\\disk_io.rs","byte_start":438,"byte_end":439,"line_start":19,"line_end":19,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"            Ok(content.lines().map(|s| s.to_string()).collect())","highlight_start":37,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":439,"byte_end":439,"line_start":19,"line_end":19,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"            Ok(content.lines().map(|s| s.to_string()).collect())","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:19:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(content.lines().map(|s| s.to_string()).collect())\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[96m-\u001b[0m \u001b[1m\u001b[96mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            Ok(content.lines().map(|s\u001b[92m: /* Type */\u001b[0m| s.to_string()).collect())\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[92m++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":414,"byte_end":416,"line_start":19,"line_end":19,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(content.lines().map(|s| s.to_string()).collect())","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fs;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:19:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(content.lines().map(|s| s.to_string()).collect())\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Vec`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":501,"byte_end":504,"line_start":21,"line_end":21,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"            Ok(Vec::new())","highlight_start":16,"highlight_end":19}],"label":"use of undeclared type `Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:21:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Vec::new())\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":498,"byte_end":500,"line_start":21,"line_end":21,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Vec::new())","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fs;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:21:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Vec::new())\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":579,"byte_end":585,"line_start":25,"line_end":25,"column_start":46,"column_end":52,"is_primary":true,"text":[{"text":"    pub fn save_installed(&self, packages: &[String]) -> io::Result<()> {","highlight_start":46,"highlight_end":52}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:25:46\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn save_installed(&self, packages: &[String]) -> io::Result<()> {\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":828,"byte_end":830,"line_start":32,"line_end":32,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(installed.contains(&package.to_string()))","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fs;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:32:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m32\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(installed.contains(&package.to_string()))\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":29,"byte_end":35,"line_start":1,"line_end":1,"column_start":30,"column_end":36,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":30,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:1:30\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_command(args: &[String]) -> Result<Command, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":41,"byte_end":47,"line_start":1,"line_end":1,"column_start":42,"column_end":48,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":42,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:1:42\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_command(args: &[String]) -> Result<Command, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":57,"byte_end":63,"line_start":1,"line_end":1,"column_start":58,"column_end":64,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":58,"highlight_end":64}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":20,"byte_end":20,"line_start":1,"line_end":1,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:1:58\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_command(args: &[String]) -> Result<Command, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn parse_command\u001b[92m<String>\u001b[0m(args: &[String]) -> Result<Command, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                     \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":108,"byte_end":111,"line_start":3,"line_end":3,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"        return Err(\"Usage: tomato-pm <command> [package]\".to_string());","highlight_start":16,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:3:16\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         return Err(\"Usage: tomato-pm <command> [package]\".to_string());\n  \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":278,"byte_end":281,"line_start":9,"line_end":9,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(\"install requires a package name\".to_string())","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:9:17\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"install requires a package name\".to_string())\n  \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":368,"byte_end":370,"line_start":11,"line_end":11,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Command::Install(args[2].clone()))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:11:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m11\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Command::Install(args[2].clone()))\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":519,"byte_end":522,"line_start":16,"line_end":16,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(\"remove requires a package name\".to_string())","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:16:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"remove requires a package name\".to_string())\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":608,"byte_end":610,"line_start":18,"line_end":18,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Command::Remove(args[2].clone()))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:18:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m18\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Command::Remove(args[2].clone()))\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":690,"byte_end":692,"line_start":21,"line_end":21,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"        \"list\" => Ok(Command::List),","highlight_start":19,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:21:19\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         \"list\" => Ok(Command::List),\n   \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":782,"byte_end":785,"line_start":24,"line_end":24,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(\"search requires a query\".to_string())","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:24:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m24\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"search requires a query\".to_string())\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":864,"byte_end":866,"line_start":26,"line_end":26,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Command::Search(args[2].clone()))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:26:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Command::Search(args[2].clone()))\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":941,"byte_end":944,"line_start":29,"line_end":29,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(format!(\"Unknown command: {}\", args[1])),","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\api\\cli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub fn parse_command(args: &[String]) -> Result<Command, String> {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:29:14\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m29\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(format!(\"Unknown command: {}\", args[1])),\n   \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":1050,"byte_end":1056,"line_start":35,"line_end":35,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"    Install(String),","highlight_start":13,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:35:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Install(String),\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":1071,"byte_end":1077,"line_start":36,"line_end":36,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    Remove(String),","highlight_start":12,"highlight_end":18}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:36:12\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m36\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Remove(String),\n   \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":1103,"byte_end":1109,"line_start":38,"line_end":38,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    Search(String),","highlight_start":12,"highlight_end":18}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:38:12\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Search(String),\n   \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":70,"byte_end":76,"line_start":3,"line_end":3,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":37,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:3:37\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":85,"byte_end":91,"line_start":3,"line_end":3,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":51,"byte_end":51,"line_start":3,"line_end":3,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:3:52\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn parse_toml\u001b[92m<String>\u001b[0m(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                  \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":93,"byte_end":99,"line_start":3,"line_end":3,"column_start":60,"column_end":66,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":60,"highlight_end":66}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":51,"byte_end":51,"line_start":3,"line_end":3,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:3:60\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn parse_toml\u001b[92m<String>\u001b[0m(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                  \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":102,"byte_end":108,"line_start":3,"line_end":3,"column_start":69,"column_end":75,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":69,"highlight_end":75}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":51,"byte_end":51,"line_start":3,"line_end":3,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:3:69\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn parse_toml(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn parse_toml\u001b[92m<String>\u001b[0m(content: &str) -> Result<HashMap<String, String>, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                  \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":557,"byte_end":561,"line_start":18,"line_end":18,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(eq_pos) = line.find('=') {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:18:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m18\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(eq_pos) = line.find('=') {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1349,"byte_end":1352,"line_start":38,"line_end":38,"column_start":20,"column_end":23,"is_primary":true,"text":[{"text":"            return Err(format!(\"Invalid line {}: {}\", line_num + 1, line));","highlight_start":20,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:38:20\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             return Err(format!(\"Invalid line {}: {}\", line_num + 1, line));\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1431,"byte_end":1433,"line_start":42,"line_end":42,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(map)","highlight_start":5,"highlight_end":7}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:42:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m42\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(map)\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1481,"byte_end":1487,"line_start":45,"line_end":45,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":37,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:45:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn serialize_toml(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1489,"byte_end":1495,"line_start":45,"line_end":45,"column_start":45,"column_end":51,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":45,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:45:45\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn serialize_toml(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1501,"byte_end":1507,"line_start":45,"line_end":45,"column_start":57,"column_end":63,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":57,"highlight_end":63}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:45:57\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn serialize_toml(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                                                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1578,"byte_end":1584,"line_start":47,"line_end":47,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"    let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();","highlight_start":31,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:47:31\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1586,"byte_end":1589,"line_start":47,"line_end":47,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"    let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();","highlight_start":39,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:47:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1591,"byte_end":1597,"line_start":47,"line_end":47,"column_start":44,"column_end":50,"is_primary":true,"text":[{"text":"    let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();","highlight_start":44,"highlight_end":50}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:47:44\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1599,"byte_end":1605,"line_start":47,"line_end":47,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"    let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1466,"byte_end":1466,"line_start":45,"line_end":45,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"pub fn serialize_toml(map: &HashMap<String, String>) -> String {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:47:52\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut sections: HashMap<String, Vec<(String, String)>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m45\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn serialize_toml\u001b[92m<String>\u001b[0m(map: &HashMap<String, String>) -> String {\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1676,"byte_end":1680,"line_start":50,"line_end":50,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(dot_pos) = key.find('.') {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:50:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(dot_pos) = key.find('.') {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":294,"byte_end":300,"line_start":12,"line_end":12,"column_start":20,"column_end":26,"is_primary":true,"text":[{"text":"pub fn run(args: &[String]) {","highlight_start":20,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:12:20\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn run(args: &[String]) {\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":409,"byte_end":411,"line_start":15,"line_end":15,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(Command::Install(pkg)) => {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:15:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m15\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(Command::Install(pkg)) => {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":585,"byte_end":587,"line_start":18,"line_end":18,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"            if let Ok(content) = std::fs::read_to_string(\"/var/lib/tomato/available.toml\") {","highlight_start":20,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:18:20\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m18\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Ok(content) = std::fs::read_to_string(\"/var/lib/tomato/available.toml\") {\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":683,"byte_end":685,"line_start":19,"line_end":19,"column_start":24,"column_end":26,"is_primary":true,"text":[{"text":"                if let Ok(parsed) = parse_toml(&content) {","highlight_start":24,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:19:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Ok(parsed) = parse_toml(&content) {\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":937,"byte_end":940,"line_start":23,"line_end":23,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"                            let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();","highlight_start":39,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();\n   \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":941,"byte_end":947,"line_start":23,"line_end":23,"column_start":43,"column_end":49,"is_primary":true,"text":[{"text":"                            let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();","highlight_start":43,"highlight_end":49}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":285,"byte_end":285,"line_start":12,"line_end":12,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"pub fn run(args: &[String]) {","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn run\u001b[92m<String>\u001b[0m(args: &[String]) {\n   \u001b[1m\u001b[96m|\u001b[0m           \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1438,"byte_end":1440,"line_start":34,"line_end":34,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(deps) => {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:34:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m34\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(deps) => {\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1526,"byte_end":1528,"line_start":36,"line_end":36,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"                        Ok(mut installed) => {","highlight_start":25,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:36:25\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m36\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         Ok(mut installed) => {\n   \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1889,"byte_end":1892,"line_start":43,"line_end":43,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"                            if let Err(e) = db.save_installed(&installed) {","highlight_start":36,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:43:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m43\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   if let Err(e) = db.save_installed(&installed) {\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2079,"byte_end":2082,"line_start":47,"line_end":47,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        Err(e) => println!(\"Error loading: {}\", e),","highlight_start":25,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:47:25\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2182,"byte_end":2185,"line_start":50,"line_end":50,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Dependency error: {}\", e),","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:50:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Dependency error: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2264,"byte_end":2266,"line_start":53,"line_end":53,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(Command::Remove(pkg)) => {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:53:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m53\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(Command::Remove(pkg)) => {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2352,"byte_end":2354,"line_start":55,"line_end":55,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(mut installed) => {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:55:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(mut installed) => {\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2403,"byte_end":2407,"line_start":56,"line_end":56,"column_start":28,"column_end":32,"is_primary":true,"text":[{"text":"                    if let Some(pos) = installed.iter().position(|p| p == &pkg) {","highlight_start":28,"highlight_end":32}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:56:28\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m56\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     if let Some(pos) = installed.iter().position(|p| p == &pkg) {\n   \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2538,"byte_end":2541,"line_start":58,"line_end":58,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"                        if let Err(e) = db.save_installed(&installed) {","highlight_start":32,"highlight_end":35}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:58:32\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m58\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if let Err(e) = db.save_installed(&installed) {\n   \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2917,"byte_end":2920,"line_start":67,"line_end":67,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Error loading: {}\", e),","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:67:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m67\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2996,"byte_end":2998,"line_start":70,"line_end":70,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(Command::List) => {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:70:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m70\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(Command::List) => {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3077,"byte_end":3079,"line_start":72,"line_end":72,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(installed) => {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:72:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m72\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(installed) => {\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3417,"byte_end":3420,"line_start":81,"line_end":81,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(e) => println!(\"Error loading: {}\", e),","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:81:17\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m81\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(e) => println!(\"Error loading: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3496,"byte_end":3498,"line_start":84,"line_end":84,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(Command::Search(query)) => {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:84:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m84\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(Command::Search(query)) => {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":859,"byte_end":868,"line_start":32,"line_end":32,"column_start":40,"column_end":49,"is_primary":true,"text":[{"text":"        Ok(installed.contains(&package.to_string()))","highlight_start":40,"highlight_end":49}],"label":"method not found in `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:32:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m32\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(installed.contains(&package.to_string()))\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3611,"byte_end":3617,"line_start":86,"line_end":86,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            let mut available: HashMap<String, Vec<String>> = HashMap::new();","highlight_start":40,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":285,"byte_end":285,"line_start":12,"line_end":12,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"pub fn run(args: &[String]) {","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:86:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let mut available: HashMap<String, Vec<String>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn run\u001b[92m<String>\u001b[0m(args: &[String]) {\n   \u001b[1m\u001b[96m|\u001b[0m           \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Vec` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3619,"byte_end":3622,"line_start":86,"line_end":86,"column_start":48,"column_end":51,"is_primary":true,"text":[{"text":"            let mut available: HashMap<String, Vec<String>> = HashMap::new();","highlight_start":48,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Vec` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:86:48\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let mut available: HashMap<String, Vec<String>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3623,"byte_end":3629,"line_start":86,"line_end":86,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"            let mut available: HashMap<String, Vec<String>> = HashMap::new();","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":285,"byte_end":285,"line_start":12,"line_end":12,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"pub fn run(args: &[String]) {","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:86:52\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let mut available: HashMap<String, Vec<String>> = HashMap::new();\n   \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub fn run\u001b[92m<String>\u001b[0m(args: &[String]) {\n   \u001b[1m\u001b[96m|\u001b[0m           \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3670,"byte_end":3672,"line_start":87,"line_end":87,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"            if let Ok(content) = std::fs::read_to_string(\"/var/lib/tomato/available.toml\") {","highlight_start":20,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:87:20\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m87\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Ok(content) = std::fs::read_to_string(\"/var/lib/tomato/available.toml\") {\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3768,"byte_end":3770,"line_start":88,"line_end":88,"column_start":24,"column_end":26,"is_primary":true,"text":[{"text":"                if let Ok(parsed) = parse_toml(&content) {","highlight_start":24,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:88:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Ok(parsed) = parse_toml(&content) {\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":4056,"byte_end":4059,"line_start":97,"line_end":97,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"        Err(e) => println!(\"Command error: {}\", e),","highlight_start":9,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ::core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:97:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m97\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(e) => println!(\"Command error: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use ::core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":151,"byte_end":160,"line_start":3,"line_end":3,"column_start":59,"column_end":68,"is_primary":true,"text":[{"text":"        return Err(\"Usage: tomato-pm <command> [package]\".to_string());","highlight_start":59,"highlight_end":68}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:3:59\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         return Err(\"Usage: tomato-pm <command> [package]\".to_string());\n  \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":316,"byte_end":325,"line_start":9,"line_end":9,"column_start":55,"column_end":64,"is_primary":true,"text":[{"text":"                Err(\"install requires a package name\".to_string())","highlight_start":55,"highlight_end":64}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:9:55\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"install requires a package name\".to_string())\n  \u001b[1m\u001b[96m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Vec`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\core\\solver.rs","byte_start":187,"byte_end":190,"line_start":4,"line_end":4,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"    let mut resolved = Vec::new();","highlight_start":24,"highlight_end":27}],"label":"use of undeclared type `Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `Vec`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\core\\solver.rs:4:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut resolved = Vec::new();\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":556,"byte_end":565,"line_start":16,"line_end":16,"column_start":54,"column_end":63,"is_primary":true,"text":[{"text":"                Err(\"remove requires a package name\".to_string())","highlight_start":54,"highlight_end":63}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:16:54\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"remove requires a package name\".to_string())\n   \u001b[1m\u001b[96m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":812,"byte_end":821,"line_start":24,"line_end":24,"column_start":47,"column_end":56,"is_primary":true,"text":[{"text":"                Err(\"search requires a query\".to_string())","highlight_start":47,"highlight_end":56}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:24:47\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m24\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"search requires a query\".to_string())\n   \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `String`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":178,"byte_end":184,"line_start":5,"line_end":5,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"    let mut current_section = String::new();","highlight_start":31,"highlight_end":37}],"label":"use of undeclared type `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `String`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:5:31\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut current_section = String::new();\n  \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `String`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":200,"byte_end":209,"line_start":12,"line_end":12,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"            path: path.to_string(),","highlight_start":24,"highlight_end":33}],"label":"method not found in `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:12:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             path: path.to_string(),\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":441,"byte_end":442,"line_start":19,"line_end":19,"column_start":40,"column_end":41,"is_primary":false,"text":[{"text":"            Ok(content.lines().map(|s| s.to_string()).collect())","highlight_start":40,"highlight_end":41}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\storage\\disk_io.rs","byte_start":438,"byte_end":439,"line_start":19,"line_end":19,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"            Ok(content.lines().map(|s| s.to_string()).collect())","highlight_start":37,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":439,"byte_end":439,"line_start":19,"line_end":19,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"            Ok(content.lines().map(|s| s.to_string()).collect())","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:19:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(content.lines().map(|s| s.to_string()).collect())\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[96m-\u001b[0m \u001b[1m\u001b[96mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            Ok(content.lines().map(|s\u001b[92m: /* Type */\u001b[0m| s.to_string()).collect())\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[92m++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Vec`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":501,"byte_end":504,"line_start":21,"line_end":21,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"            Ok(Vec::new())","highlight_start":16,"highlight_end":19}],"label":"use of undeclared type `Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:21:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Vec::new())\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `enumerate` found for struct `core::str::Lines<'a>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":240,"byte_end":249,"line_start":7,"line_end":7,"column_start":45,"column_end":54,"is_primary":true,"text":[{"text":"    for (line_num, line) in content.lines().enumerate() {","highlight_start":45,"highlight_end":54}],"label":"method not found in `core::str::Lines<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\gvopr\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library/core/src/iter/traits/iterator.rs","byte_start":33557,"byte_end":33566,"line_start":985,"line_end":985,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"    fn enumerate(self) -> Enumerate<Self>","highlight_start":8,"highlight_end":17}],"label":"the method is available for `core::str::Lines<'_>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `Iterator` which provides `enumerate` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::iter::Iterator;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `enumerate` found for struct `core::str::Lines<'a>` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:7:45\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     for (line_num, line) in content.lines().enumerate() {\n    \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `core::str::Lines<'_>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0mC:\\Users\\gvopr\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library/core/src/iter/traits/iterator.rs:985:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m985\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn enumerate(self) -> Enumerate<Self>\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m---------\u001b[0m \u001b[1m\u001b[96mthe method is available for `core::str::Lines<'_>` here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `Iterator` which provides `enumerate` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::iter::Iterator;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":274,"byte_end":278,"line_start":8,"line_end":8,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"        let line = line.trim();","highlight_start":20,"highlight_end":24}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:8:20\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let line = line.trim();\n  \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `String`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1532,"byte_end":1538,"line_start":46,"line_end":46,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let mut output = String::new();","highlight_start":22,"highlight_end":28}],"label":"use of undeclared type `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `String`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:46:22\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m46\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut output = String::new();\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `String`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1692,"byte_end":1695,"line_start":50,"line_end":50,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"        if let Some(dot_pos) = key.find('.') {","highlight_start":32,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:50:32\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(dot_pos) = key.find('.') {\n   \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Vec`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1858,"byte_end":1861,"line_start":53,"line_end":53,"column_start":59,"column_end":62,"is_primary":true,"text":[{"text":"            sections.entry(section.to_string()).or_insert(Vec::new()).push((subkey.to_string(), value.clone()));","highlight_start":59,"highlight_end":62}],"label":"use of undeclared type `Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:53:59\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m53\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             sections.entry(section.to_string()).or_insert(Vec::new()).push((subkey.to_string(), value.clone()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1896,"byte_end":1901,"line_start":53,"line_end":53,"column_start":97,"column_end":102,"is_primary":true,"text":[{"text":"            sections.entry(section.to_string()).or_insert(Vec::new()).push((subkey.to_string(), value.clone()));","highlight_start":97,"highlight_end":102}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:53:97\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m53\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             sections.entry(section.to_string()).or_insert(Vec::new()).push((subkey.to_string(), value.clone()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                                                                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1962,"byte_end":1971,"line_start":55,"line_end":55,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"            sections.entry(\"\".to_string()).or_insert(Vec::new()).push((key.clone(), value.clone()));","highlight_start":31,"highlight_end":40}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:55:31\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             sections.entry(\"\".to_string()).or_insert(Vec::new()).push((key.clone(), value.clone()));\n   \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Vec`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1985,"byte_end":1988,"line_start":55,"line_end":55,"column_start":54,"column_end":57,"is_primary":true,"text":[{"text":"            sections.entry(\"\".to_string()).or_insert(Vec::new()).push((key.clone(), value.clone()));","highlight_start":54,"highlight_end":57}],"label":"use of undeclared type `Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:55:54\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             sections.entry(\"\".to_string()).or_insert(Vec::new()).push((key.clone(), value.clone()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\storage\\disk_io.rs","byte_start":859,"byte_end":868,"line_start":32,"line_end":32,"column_start":40,"column_end":49,"is_primary":true,"text":[{"text":"        Ok(installed.contains(&package.to_string()))","highlight_start":40,"highlight_end":49}],"label":"method not found in `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\storage\\disk_io.rs:32:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m32\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(installed.contains(&package.to_string()))\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":2105,"byte_end":2112,"line_start":60,"line_end":60,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        if !section.is_empty() {","highlight_start":13,"highlight_end":20}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:60:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m60\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if !section.is_empty() {\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":798,"byte_end":801,"line_start":21,"line_end":21,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"                        if key.ends_with(\".deps\") {","highlight_start":28,"highlight_end":31}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:21:28\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if key.ends_with(\".deps\") {\n   \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":951,"byte_end":956,"line_start":23,"line_end":23,"column_start":53,"column_end":58,"is_primary":true,"text":[{"text":"                            let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();","highlight_start":53,"highlight_end":58}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:53\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();\n   \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":151,"byte_end":160,"line_start":3,"line_end":3,"column_start":59,"column_end":68,"is_primary":true,"text":[{"text":"        return Err(\"Usage: tomato-pm <command> [package]\".to_string());","highlight_start":59,"highlight_end":68}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:3:59\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         return Err(\"Usage: tomato-pm <command> [package]\".to_string());\n  \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":991,"byte_end":1000,"line_start":23,"line_end":23,"column_start":93,"column_end":102,"is_primary":true,"text":[{"text":"                            let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();","highlight_start":93,"highlight_end":102}],"label":"method not found in `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:93\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();\n   \u001b[1m\u001b[96m|\u001b[0m                                                                                       \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1239,"byte_end":1248,"line_start":30,"line_end":30,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"            available.entry(\"base\".to_string()).or_insert(vec![]);","highlight_start":36,"highlight_end":45}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:30:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             available.entry(\"base\".to_string()).or_insert(vec![]);\n   \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":316,"byte_end":325,"line_start":9,"line_end":9,"column_start":55,"column_end":64,"is_primary":true,"text":[{"text":"                Err(\"install requires a package name\".to_string())","highlight_start":55,"highlight_end":64}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:9:55\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"install requires a package name\".to_string())\n  \u001b[1m\u001b[96m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1309,"byte_end":1318,"line_start":31,"line_end":31,"column_start":38,"column_end":47,"is_primary":true,"text":[{"text":"            available.entry(\"kernel\".to_string()).or_insert(vec![\"base\".to_string()]);","highlight_start":38,"highlight_end":47}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:31:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m31\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             available.entry(\"kernel\".to_string()).or_insert(vec![\"base\".to_string()]);\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3879,"byte_end":3882,"line_start":90,"line_end":90,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"                        if key.contains(&query) {","highlight_start":28,"highlight_end":31}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:90:28\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m90\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if key.contains(&query) {\n   \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":556,"byte_end":565,"line_start":16,"line_end":16,"column_start":54,"column_end":63,"is_primary":true,"text":[{"text":"                Err(\"remove requires a package name\".to_string())","highlight_start":54,"highlight_end":63}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:16:54\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"remove requires a package name\".to_string())\n   \u001b[1m\u001b[96m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\api\\cli.rs","byte_start":812,"byte_end":821,"line_start":24,"line_end":24,"column_start":47,"column_end":56,"is_primary":true,"text":[{"text":"                Err(\"search requires a query\".to_string())","highlight_start":47,"highlight_end":56}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\api\\cli.rs:24:47\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m24\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(\"search requires a query\".to_string())\n   \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0282, E0425, E0433, E0463, E0531, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0282, E0425, E0433, E0463, E0531, E0599.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `String`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":178,"byte_end":184,"line_start":5,"line_end":5,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"    let mut current_section = String::new();","highlight_start":31,"highlight_end":37}],"label":"use of undeclared type `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `String`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:5:31\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut current_section = String::new();\n  \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `String`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `enumerate` found for struct `core::str::Lines<'a>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":240,"byte_end":249,"line_start":7,"line_end":7,"column_start":45,"column_end":54,"is_primary":true,"text":[{"text":"    for (line_num, line) in content.lines().enumerate() {","highlight_start":45,"highlight_end":54}],"label":"method not found in `core::str::Lines<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\gvopr\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library/core/src/iter/traits/iterator.rs","byte_start":33557,"byte_end":33566,"line_start":985,"line_end":985,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"    fn enumerate(self) -> Enumerate<Self>","highlight_start":8,"highlight_end":17}],"label":"the method is available for `core::str::Lines<'_>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `Iterator` which provides `enumerate` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::iter::Iterator;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `enumerate` found for struct `core::str::Lines<'a>` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:7:45\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     for (line_num, line) in content.lines().enumerate() {\n    \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `core::str::Lines<'_>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0mC:\\Users\\gvopr\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library/core/src/iter/traits/iterator.rs:985:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m985\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn enumerate(self) -> Enumerate<Self>\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m---------\u001b[0m \u001b[1m\u001b[96mthe method is available for `core::str::Lines<'_>` here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `Iterator` which provides `enumerate` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use core::iter::Iterator;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":274,"byte_end":278,"line_start":8,"line_end":8,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"        let line = line.trim();","highlight_start":20,"highlight_end":24}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:8:20\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let line = line.trim();\n  \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `String`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1532,"byte_end":1538,"line_start":46,"line_end":46,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let mut output = String::new();","highlight_start":22,"highlight_end":28}],"label":"use of undeclared type `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `String`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:46:22\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m46\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut output = String::new();\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `String`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1692,"byte_end":1695,"line_start":50,"line_end":50,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"        if let Some(dot_pos) = key.find('.') {","highlight_start":32,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:50:32\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(dot_pos) = key.find('.') {\n   \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Vec`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1858,"byte_end":1861,"line_start":53,"line_end":53,"column_start":59,"column_end":62,"is_primary":true,"text":[{"text":"            sections.entry(section.to_string()).or_insert(Vec::new()).push((subkey.to_string(), value.clone()));","highlight_start":59,"highlight_end":62}],"label":"use of undeclared type `Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:53:59\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m53\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             sections.entry(section.to_string()).or_insert(Vec::new()).push((subkey.to_string(), value.clone()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1896,"byte_end":1901,"line_start":53,"line_end":53,"column_start":97,"column_end":102,"is_primary":true,"text":[{"text":"            sections.entry(section.to_string()).or_insert(Vec::new()).push((subkey.to_string(), value.clone()));","highlight_start":97,"highlight_end":102}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:53:97\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m53\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             sections.entry(section.to_string()).or_insert(Vec::new()).push((subkey.to_string(), value.clone()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                                                                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1962,"byte_end":1971,"line_start":55,"line_end":55,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"            sections.entry(\"\".to_string()).or_insert(Vec::new()).push((key.clone(), value.clone()));","highlight_start":31,"highlight_end":40}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:55:31\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             sections.entry(\"\".to_string()).or_insert(Vec::new()).push((key.clone(), value.clone()));\n   \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Vec`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":1985,"byte_end":1988,"line_start":55,"line_end":55,"column_start":54,"column_end":57,"is_primary":true,"text":[{"text":"            sections.entry(\"\".to_string()).or_insert(Vec::new()).push((key.clone(), value.clone()));","highlight_start":54,"highlight_end":57}],"label":"use of undeclared type `Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:55:54\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             sections.entry(\"\".to_string()).or_insert(Vec::new()).push((key.clone(), value.clone()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\parser\\toml.rs","byte_start":2105,"byte_end":2112,"line_start":60,"line_end":60,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        if !section.is_empty() {","highlight_start":13,"highlight_end":20}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\parser\\toml.rs:60:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m60\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if !section.is_empty() {\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":798,"byte_end":801,"line_start":21,"line_end":21,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"                        if key.ends_with(\".deps\") {","highlight_start":28,"highlight_end":31}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:21:28\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if key.ends_with(\".deps\") {\n   \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":951,"byte_end":956,"line_start":23,"line_end":23,"column_start":53,"column_end":58,"is_primary":true,"text":[{"text":"                            let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();","highlight_start":53,"highlight_end":58}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:53\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();\n   \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":991,"byte_end":1000,"line_start":23,"line_end":23,"column_start":93,"column_end":102,"is_primary":true,"text":[{"text":"                            let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();","highlight_start":93,"highlight_end":102}],"label":"method not found in `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:93\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   let deps: Vec<String> = value.split(',').map(|s: &str| s.trim().to_string()).collect();\n   \u001b[1m\u001b[96m|\u001b[0m                                                                                       \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1239,"byte_end":1248,"line_start":30,"line_end":30,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"            available.entry(\"base\".to_string()).or_insert(vec![]);","highlight_start":36,"highlight_end":45}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:30:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             available.entry(\"base\".to_string()).or_insert(vec![]);\n   \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1309,"byte_end":1318,"line_start":31,"line_end":31,"column_start":38,"column_end":47,"is_primary":true,"text":[{"text":"            available.entry(\"kernel\".to_string()).or_insert(vec![\"base\".to_string()]);","highlight_start":38,"highlight_end":47}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:31:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m31\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             available.entry(\"kernel\".to_string()).or_insert(vec![\"base\".to_string()]);\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":3879,"byte_end":3882,"line_start":90,"line_end":90,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"                        if key.contains(&query) {","highlight_start":28,"highlight_end":31}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:90:28\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m90\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if key.contains(&query) {\n   \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0282, E0425, E0433, E0463, E0531, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0282, E0425, E0433, E0463, E0531, E0599.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///D:/ospab-projects/ospab.os/tomato-pm#0.1.0","manifest_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tomato_pm","src_path":"D:\\ospab-projects\\ospab.os\\tomato-pm\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}}
{"reason":"build-finished","success":false}
